import os, re

class CTypedIdentifier():
    pattern = r"(?P<type>[^\)]+\W)(?P<name>\w+)"

    def __init__(self, type: str, identifier: str):
        self.type = type.strip()
        self.identifier = identifier.strip()

    def __str__(self):
        return self.type + " " + self.identifier

    def __repr__(self):
        return str(self)

    def parse(text) -> 'CTypedIdentifier':
        match = re.match(CTypedIdentifier.pattern, text.strip())
        return CTypedIdentifier(match.group('type'), match.group('name'))


class CFunction():
    pattern = r"(/\*[ ]*(?P<since>since v[^ \*]+)[ ]*\*/)?[ \n]*(?P<type_and_name>[^\(\)\n]+)\((?P<args>[^\(\)]*)\);"

    def __init__(self, name: CTypedIdentifier, args: list[CTypedIdentifier], since_tag = None):
        self.name = name
        self.args = args
        self.since_tag = since_tag

    def __str__(self):
        output = ""

        if self.since_tag is not None:
            output += "/* " + self.since_tag + " */"

        output += str(self.name)

        output += '('

        if len(self.args) == 0:
            output += 'void'
        else:
            output += ", ".join([str(arg) for arg in self.args])

        output += ')'

        return output

    def __repr__(self):
        return str(self)

    def parse(text) -> 'CFunction':
        match = re.match(CFunction.pattern, text)

        name = CTypedIdentifier.parse(match.group('type_and_name'))
        since_tag = match.group('since')

        args = []
        if match.group('args') != 'void':
            for arg_text in match.group('args').split(','):
                args.append(CTypedIdentifier.parse(arg_text))

        return CFunction(name, args, since_tag=since_tag)

    def with_name_decorated(self, prefix = '', suffix = '') -> 'CFunction':
        new_identifier = prefix + self.name.identifier + suffix
        return CFunction(CTypedIdentifier(self.name.type, new_identifier), self.args)

    def default_implementation(self):
        text = str(self) + "\n{\n"
        text += self.argument_ignore_statement() + "\n"
        text += self.default_return_statement() + "\n"
        text += "}\n"
        return text

    def argument_ignore_statement(self):
        if len(self.args) == 0:
            return ""

        return " ".join(["(void) " + arg.identifier + ";" for arg in self.args])

    def default_return_statement(self):
        if self.name.type == "void":
            return "/* no-op */"
        elif self.name.type == "fj_err_t":
            return "return FJ_ERR_UNSUPPORTED;"
        else:
            return "return 0;"


class CParsedSource():
    def __init__(self, functions: list[CFunction]):
        self.functions = functions

    # Recognizes only the Fejix source code style!
    # The type must be on the same line as the identifier with it
    def parse(text) -> 'CParsedSource':
        functions = []
        for match in re.finditer(CFunction.pattern, text):
            functions.append(CFunction.parse(match.group(0)))
        return CParsedSource(functions)


class Autogen():
    autogen_header = "/* Automatically generated by tools/autogen/autogen.py, do not edit! */\n\n"

    def __init__(self):
        script_dir = os.path.dirname(os.path.realpath(__file__))
        self.project_path = os.path.realpath(os.path.join(script_dir, "..", ".."))

        self.input_path = os.path.join(self.project_path, "include", "fejix", "interface")

        self.default_output_path = os.path.join(self.project_path, "src", "default", "autogen")
        self.loader_output_path = os.path.join(self.project_path, "src", "loader", "autogen")

    def process_files(self):
        for file_name in os.listdir(self.input_path):
            self.process_file(file_name)

    def process_file(self, file_name: str):
        source = self.read_input_file(file_name)
        parsed_source = CParsedSource.parse(source)
        self.generate_output(parsed_source, file_name)

    def generate_output(self, parsed_source: CParsedSource, file_name: str):
        self.generate_default_implementation(parsed_source, file_name)
        self.generate_loader(parsed_source, file_name)

    def generate_default_implementation(self, parsed_source: CParsedSource, file_name: str):
        text = Autogen.autogen_header

        text += "#include <fejix/interface/" + file_name + ">\n\n"

        for function in parsed_source.functions:
            text += function.default_implementation() + "\n"

        self.write_output_file(self.default_output_path, file_name, text)

    def generate_loader(self, parsed_source: CParsedSource, file_name: str):
        pass

    def file_paths(self, dir_path: str):
        for name in os.listdir(dir_path):
            path = os.path.join(dir_path, name)
            if os.path.isfile(path):
                yield path

    def read_file(self, file_path: str):
        with open(file_path) as file:
            return file.read()

    def write_file(self, file_path: str, text: str):
        with open(file_path, "w") as file:
            file.write(text)

    def read_input_file(self, file_name: str):
        return self.read_file(os.path.join(self.input_path, file_name))

    def write_output_file(self, output_path: str, file_name: str, text: str):
        self.write_file(os.path.join(output_path, file_name), text)


def main():
    autogen = Autogen()
    autogen.process_files()


if __name__ == "__main__":
    main()

