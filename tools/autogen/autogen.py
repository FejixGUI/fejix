import os, re


def read_file(file_path: str):
    with open(file_path) as file:
        return file.read()

def write_file(file_path: str, text: str):
    with open(file_path, "w") as file:
        file.write(text)


class CTypedIdentifier():
    pattern = r"(?P<type>[^\)]+\W)(?P<name>\w+)"

    def __init__(self, type: str, name: str):
        self.type = type.strip()
        self.name = name.strip()

    def __str__(self):
        return self.type + " " + self.name

    def __repr__(self):
        return str(self)

    def parse(text: str) -> 'CTypedIdentifier':
        match = re.match(CTypedIdentifier.pattern, text.strip())
        return CTypedIdentifier(match.group('type'), match.group('name'))


class CFunction():
    pattern = r"(?P<tag>[^\(\)\n]+)\((?P<args>[^\(\)]*)\);"

    def __init__(self, tag: CTypedIdentifier, args: list[CTypedIdentifier]):
        self.tag = tag
        self.args = args

    def __str__(self):
        return self.prototype()

    def __repr__(self):
        return str(self)

    def parse(text: str) -> 'CFunction':
        match = re.match(CFunction.pattern, text)

        name = CTypedIdentifier.parse(match.group('tag'))

        args = []
        if match.group('args') != 'void':
            for arg_text in match.group('args').split(','):
                args.append(CTypedIdentifier.parse(arg_text))

        return CFunction(name, args)

    def prototype(self) -> str:
        return f"{self.tag}({self.define_args()})"

    def function_type(self) -> str:
        return f"{self.tag.type}(*)({self.define_args()})"

    def has_void_args(self) -> bool:
        return len(self.args) == 0

    def define_args(self) -> str:
        if self.has_void_args():
            return "void"
        else:
            return ", ".join([str(arg) for arg in self.args])

    def pass_args(self) -> str:
        return ", ".join([arg.name for arg in self.args])

    def ignore_arguments(self):
        if len(self.args) == 0:
            return ""

        return f"{' '.join([f'(void) {arg.name};' for arg in self.args])}"

    def return_(self):
        if self.tag.type == "void":
            return ""
        else:
            return "return "

    def default_return_value(self):
        if self.tag.type == "void":
            return "/* do nothing by default */"
        elif self.tag.type == "fj_err_t":
            return "FJ_ERR_UNSUPPORTED"
        else:
            return "0"

    def return_default(self):
        return f"{self.return_()}{self.default_return_value()}"

    def pointer_name(self) -> str:
        return '_' + self.tag.name + '_ptr'

    def callable_pointer(self):
        return f"({self.function_type()}){self.pointer_name()}"

    def call_pointer(self):
        return f"({self.callable_pointer()})({self.pass_args()})"

    def return_called_pointer(self):
        return f"{self.return_()}{self.call_pointer()}"

    def default_implementation(self) -> str:
        return (
            f"{self.prototype()}\n"
            "{\n"
            f"    {self.ignore_arguments()}\n"
            f"    {self.return_default()};\n"
            "}\n"
        )

    def loader_implementation(self):
        return (
            f"void *{self.pointer_name()};\n"
            f"{self.prototype()}\n"
            "{\n"
            f"    if ({self.pointer_name()} != NULL)\n"
            f"        {self.return_called_pointer()};\n"
            f"    {self.return_default()};\n"
            "}\n"
        )


class CSource():
    def __init__(self, file_name: str, functions: list[CFunction]):
        self.functions = functions
        self.file_name = file_name

    def parse_file(file_path: str) -> 'CSource':
        functions = []
        for match in re.finditer(CFunction.pattern, read_file(file_path)):
            functions.append(CFunction.parse(match.group(0)))

        return CSource(os.path.basename(file_path), functions)

    def default_implementation(self) -> str:
        return (
            f"{Autogen.autogen_header}"
            f"#include <fejix/interface/{self.file_name}>\n"
            "\n"
            f"{'\n'.join(function.default_implementation() \
                            for function in self.functions)}"
        )

    def loader_implementation(self) -> str:
        return (
            f"{Autogen.autogen_header}"
            "#include <src/loader/loader.h>\n"
            "\n"
            f"#include <fejix/interface/{self.file_name}>\n"
            "\n"
            f"{'\n'.join([function.loader_implementation() \
                            for function in self.functions])}"
        )


class Autogen():
    autogen_header = "/* Automatically generated by tools/autogen/autogen.py, do not edit! */\n\n"

    def __init__(self):
        script_dir = os.path.dirname(os.path.realpath(__file__))
        self.project_path = os.path.realpath(os.path.join(script_dir, "..", ".."))

        self.input_path = os.path.join(self.project_path, "include", "fejix", "interface")

        self.default_output_path = os.path.join(self.project_path, "src", "default", "autogen")
        self.loader_output_path = os.path.join(self.project_path, "src", "loader", "autogen")

    def process_files(self):
        sources = list(self.input_sources())
        self.generate_default_implementations(sources)
        self.generate_loadable_implementations(sources)

    def generate_default_implementations(self, sources: list[CSource]):
        for source in sources:
            self.write_default_implementation(source.file_name, source.default_implementation())

    def write_default_implementation(self, file_name: str, text: str):
        write_file(os.path.join(self.default_output_path, file_name), text)

    def generate_loadable_implementations(self, sources: list[CSource]):
        functions = []
        for source in sources:
            functions += source.functions
            self.write_loader_implementation(source.file_name, source.loader_implementation())

        self.write_loader_implementation("loader.c", self.loader_function_list(functions))

    def loader_function_list(self, functions: list[CFunction]) -> str:
        return (
            f"{Autogen.autogen_header}"
            "#include <src/loader/loader.h>\n"
            "\n"
            "char const *fj_loader_function_names[] = {\n"
            f"{''.join([f'"{function.tag.name}",\n' \
                        for function in functions])}"
            "};\n"
            "\n"
            f"{''.join([f'extern void *{function.pointer_name()};\n' \
                        for function in functions])}"
            "\n"
            "void **fj_loader_function_pointers[] = {\n"
            f"{''.join([f'&{function.pointer_name()},\n' \
                        for function in functions])}"
            "};\n"
            "\n"
            f"uint32_t fj_loader_function_count = {len(functions)};\n"
        )

    def write_loader_implementation(self, file_name: str, text: str):
        write_file(os.path.join(self.loader_output_path, file_name), text)

    def input_sources(self):
        for file_name in os.listdir(self.input_path):
            yield CSource.parse_file(os.path.join(self.input_path, file_name))


if __name__ == "__main__":
    autogen = Autogen()
    autogen.process_files()

