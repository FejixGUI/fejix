/**

\page contribute Contribute

\tableofcontents


## Project organisation

\todo Discuss the tools, the development process, the organisation of the project and its backends.

\todo Discuss memory allocation, logging, other internal tools...

\todo Discuss the app, services, objects and state objects,

To be written...

## Code style

These are some code style aspects that cannot be handled by automated tools.

### High-level

#### Error handling

The error handling looks like this:

\code{.c}
enum fj_status foo()
{
    enum fj_status s;

    s = bar();
    if (s) {
        // Do something
        return s; // Pass the error to the caller
    }

    s = baz();
    if (s) {
        // Do something
        return s; // Pass the error to the caller
    }

    return FJ_OK;
}
\endcode

In many cases it is even like this:

\code{.c}
enum fj_status foo()
{
    enum fj_status s;

    waka(); // This must be cancelled on failure

    s = bar();
    if (s) {
        cancel_waka(); // Roll something back if needed
        FJ_ERROR("foo failed"); // Debug log
        return s;
    }

    s = baz();
    if (s) {
        cancel_waka(); // Roll something back if needed
        FJ_ERROR("baz failed"); // Debug log
        return s;
    }

    return FJ_OK;
}
\endcode

Yes, this is quite some code, but well... idk, error handling is important.
In such a low-level project this would be inevitable in any programming language out there
because we just use *so many* system APIs.

#### Constructors and destructors

All destructors (`_del()`, `_deinit()`) *must* correctly destruct a partially constructed object and
*must* succeed on a newly allocated zero-initialised object.

That makes constructor/destructor code shorter and simpler. This is how it must look like:

\code{.c}
struct foo {
    struct bar *bar;
    struct baz *baz;
};

enum fj_status foo_new(struct foo **out_foo)
{
    enum fj_status s;

    struct foo *foo;
    s = FJ_ALLOC(&foo);
    if (s)
        return s;

    s = bar_new(&foo->bar)
    if (s) {
        foo_del(foo);
        return s;
    }

    s = baz_new(&foo->baz);
    if (s) {
        foo_del(foo);
        return s;
    }

    *out_foo = foo;
    return FJ_OK;
}

void foo_del(struct foo *foo)
{
    // The order of deinitialisation is reverse here,
    // but in many cases it does not really matter

    if (foo->baz) {
        baz_del(foo->baz);
    }

    if (foo->bar) {
        bar_del(foo->bar);
    }

    FJ_FREE(&foo);
}
\endcode

Notice how error handling code is similar in both cases when `foo->bar` and `foo->baz` fail to
initialise. If destructors only worked on fully constructed objects, handling errors
would need to be done inside constructors, which is too hard and bug-prone in C.

### Naming

#### Macros

- `FJ_COMPILE_OPT_XXX` - macro definitions defined externally by the build system
- `FJ_PRIVATE_OPT_XXX` - macro definitions defined by the project code
- `FJ_INCLUDE_OPT_XXX` - macro definitions defined by the user code that includes the headers
- `FEJIX_FOO_BAR_BAZ_H_` - a header guard for `<fejix/foo/bar_baz.h>`

*/
